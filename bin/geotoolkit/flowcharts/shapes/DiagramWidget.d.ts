import {BaseWidget} from '../../widgets/BaseWidget';
import {AnnotationLocation} from '../../layout/AnnotationLocation';
import {Group} from '../../scene/Group';
import {Rect} from '../../util/Rect';
import {DiagramTools} from './DiagramTools';
import {Node} from '../../scene/Node';
import {Point} from '../../util/Point';
import {IComponent} from './IComponent';
import {LiteEvent} from '../utils/LiteEvent';

/**
 * A basic widget that displays visuals, provides tools for manipulation, and API for persistence, copy/paste, delete, selection and other functions.
 */
export class DiagramWidget extends BaseWidget {
    /**
     * A basic widget that displays visuals, provides tools for manipulation, and API for persistence, copy/paste, delete, selection and other functions.
     * @param options settings for the widget
     */
    constructor(options?: object);
    /**
     * Gets annotation at specified location
     * @param location Enum of annotation locations used to specify direction to insert
     */
    getAnnotation(location: AnnotationLocation): Group | null;
    /**
     * Sets diagram size. It affects both on physical and model size
     * @param rect a new model limits
     */
    setDiagramLimits(rect: Rect): this;
    /**
     * Toggles the tool
     * @param toolType a tool type to activate
     */
    toggleTool(toolType: DiagramTools): this;
    /**
     * Gets a currently active tool
     */
    getActiveTool(): string;
    /**
     * Gets current widget scale {x: number, y: number}
     */
    getScale(): object;
    /**
     * Sets the specified scale-x and scale-y factors on the model
     * @param sx horizontal scale
     * @param sy vertical scale
     */
    setScale(sx: number, sy: number): this;
    /**
     * Zoom In
     */
    zoomIn(): void;
    /**
     * Zoom Out
     */
    zoomOut(): void;
    /**
     * Scales the model for the specified amount for X and Y axis
     * @param scale scale factor that will be applied to vertical and horizontal zoom
     */
    scaleModel(scale: number): void;
    /**
     * Returns the Model that is being used for shapes storage, diagram saving and loading
     */
    getModel(): Group;
    /**
     * Gets primary model limits
     */
    getDiagramLimits(): Rect;
    /**
     * Gets active selection
     */
    getSelection(): Node[];
    /**
     * Tells the diagram widget that the polygon/polyline edit must be finished
     */
    stopPolylineEdit(): boolean;
    /**
     * De-selects currently selected shapes
     */
    clearSelection(): this;
    /**
     * select visuals
     * @param shapes an array of shape to select
     */
    selectVisuals(shapes: Node[]): this;
    /**
     * Groups the given visuals into a group.
     * This method cuts off the visuals from primary model, creates a new group and places this group
     * into the model and selects the newly created group
     * @param visuals an array of visuals to group
     * @param groupName a name for the new group
     */
    groupVisuals(visuals: Node[], groupName?: string): this;
    /**
     * Destructs the group causing all enclosed visuals to be placed to the Model. The Local group Transformation
     * will be multiplied with Local visuals Transformations.
     * @param visuals An array of SvgGroup to decompose. Even though the method accepts base Node, everything
     * but SvgGroup (and ancestors) will be ignored.
     */
    ungroupVisuals(visuals: Node[]): this;
    /**
     * Changes z-order for the specified array of visuals, placing them "closer" to an observer.
     * If array consists of more than 1 visual, then visual with 0 index will be placed "under" visual with Nth index.
     * @param node An array of visuals to bring on top of others
     */
    bringToFront(node: Node[] | Node): this;
    /**
     * Changes z-order for the specified array of visuals, placing them "farther" from an observer.
     * If array consists of more than 1 visual, then visual with Nth index will be placed "under" visual with 0th index.
     * @param node An array of visuals to bring on top of others
     */
    sendToBack(node: Node[] | Node): this;
    /**
     * Cleans up the diagram and resets it to an original state
     */
    resetDiagram(): this;
    /**
     * Serializes the diagram into a JSON string
     */
    saveDiagram(): string;
    /**
     * Restores a diagram from the given string, which contains JSON object. This object normally generated by
     * saveDiagram() method
     * @param data well-formed JSON-string
     */
    loadDiagram(data: string): void;
    /**
     * Unfolds an array of visuals and their children into a flat (single-dimension) array of nodes.
     * geotoolkit.scene.Group instances are also added to the collection
     * @param restoredItems all restored nodes as flat array
     */
    flattenVisuals(restoredItems: Node[]): Node[];
    /**
     * Copies Seleciton into JSON object
     */
    copySelection(): string;
    /**
     * Cuts selection out of scene and returns a copy of it as JSON string
     */
    cutSelection(): string;
    /**
     * Deletes all selected visuals from the scene
     */
    deleteSelection(): this;
    /**
     * Adds the specified visual to the model
     * @param visual a shape to add
     * @param modelLocation a point where the visual will be added. Default value is (0,0)
     * @param center flag indicating if the visual should have center point at the given location
     * @param startPolylineCreation starts manipulator for polygon/polyline creation
     */
    addVisual(visual: Node, modelLocation?: Point, center?: boolean, startPolylineCreation?: boolean): IComponent;
    /**
     * Deletes the specified visual from model, if this shape exists on top
     * @param shapeToRemove a shape to remove
     */
    deleteVisual(shapeToRemove: Node): this;
    /**
     * Deletes visuals from the scene
     * @param visuals visuals to delete
     */
    deleteVisuals(visuals: Node[]): this;
    /**
     * Serializes the given visuals into a well-formed JSON object
     * @param visuals array of visuals to copy
     */
    copyVisuals(visuals: Node[]): string;
    /**
     * Serialized the given visuals into a well-formed JSON objects and cuts the visuals
     * out of scene.
     * @param visuals Array of visuals to delete
     */
    cutVisuals(visuals: Node[]): string;
    /**
     * Pastes the previously copied visuals from JSON string
     * @param data well-formed JSON data string, previously obtained with copy/cut/save methods
     * @param modelOrigin model origin point
     */
    paste(data: string, modelOrigin: Point): void;
    /**
     * Event that raises on selection change
     */
    getOnSelectionChangeEvent(): LiteEvent;
}
